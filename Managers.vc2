*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="managers.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS bindeventhandler AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: event
		*p: errormsg		&& Contains last execution error text.
		*p: errorno		&& Last error number.
		*p: eventname
		*p: object
	*</DefinedPropArrayMethod>

	errormsg = 		&& Contains last execution error text.
	errorno = 0		&& Last error number.
	eventname = .F.
	Name = "bindeventhandler"
	object = .F.
	
	PROCEDURE event
		Local cMacro As String, ;
				oException As Exception
		
		If not Empty(This.EventName)
			This.ErrorNo = 0
			This.ErrorMsg = ''
			m.cMacro = This.EventName
			Try
				This.Object.&cMacro
			Catch TO oException
				This.ErrorNo = m.oException.ErrorNo
				This.ErrorMsg = m.oException.Message
			EndTry
		Else
			This.ErrorNo = -1
			This.ErrorMsg = 'Property EventName is empty.'
		EndIf
		
	ENDPROC

	PROCEDURE Init
		Lparameters oObject, cEventName
		
		This.Object = m.oObject
		This.EventName = m.cEventName
		
	ENDPROC

ENDDEFINE

DEFINE CLASS findbox AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdNext" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdPrevious" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtFind" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: visible_assign
		*m: _find		&& Main find method.
		*m: _mouseactivation_assign
		*p: active		&& .t. when control is active, handle key events, otherwise .f..
		*p: alwaysvisible		&& Control is always visible.
		*p: findnextkey		&& Find next hotkey.
		*p: findpreviouskey		&& Find previous hotkey.
		*p: invisibleonlostfocus		&& If .t. control set to no visible on lost focus.
		*p: oobject		&& Associated object.
		*p: _mouseactivation		&& Flag for mouse activation.
		*p: _oldfindtext		&& Previous find text.
	*</DefinedPropArrayMethod>

	active = .F.		&& .t. when control is active, handle key events, otherwise .f..
	alwaysvisible = .F.		&& Control is always visible.
	findnextkey = -2		&& Find next hotkey.
	findpreviouskey = 86		&& Find previous hotkey.
	Height = 27
	invisibleonlostfocus = .T.		&& If .t. control set to no visible on lost focus.
	Name = "findbox"
	oobject = .F.		&& Associated object.
	Visible = .F.
	Width = 200
	_mouseactivation = .F.		&& Flag for mouse activation.
	_oldfindtext = 		&& Previous find text.

	ADD OBJECT 'cmdNext' AS commandbutton WITH ;
		Anchor = 13, ;
		Caption = "", ;
		Height = 25, ;
		Left = 150, ;
		Name = "cmdNext", ;
		Picture = pictures\findboxnext.bmp, ;
		PicturePosition = 14, ;
		TabIndex = 2, ;
		TabStop = .F., ;
		Top = 1, ;
		Width = 25
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdPrevious' AS commandbutton WITH ;
		Anchor = 13, ;
		Caption = "", ;
		Height = 25, ;
		Left = 174, ;
		Name = "cmdPrevious", ;
		Picture = pictures\findboxprevious.bmp, ;
		PicturePosition = 14, ;
		TabIndex = 3, ;
		TabStop = .F., ;
		Top = 1, ;
		Width = 25
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'txtFind' AS textbox WITH ;
		Anchor = 15, ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 2, ;
		Name = "txtFind", ;
		TabIndex = 1, ;
		TabStop = .F., ;
		Top = 2, ;
		Width = 148
		*< END OBJECT: BaseClass="textbox" />
	
	PROCEDURE Init
		Lparameters oObject
		
		If (Vartype(m.oObject) = 'O')
			This.oObject = m.oObject
			This.FindNextKey = m.oObject.FindNextKey
			This.FindPreviousKey = m.oObject.FindPreviousKey
			This.AlwaysVisible = m.oObject.FindBoxAlwaysVisible
			This.Visible = This.AlwaysVisible
			This.Active = .f.
			
			Local m.oGrid As Grid
			
			m.oGrid = This.oObject.oGrid
			If (Vartype(m.oGrid) = 'O')
				This.Left = m.oGrid.Left + m.oGrid.Width - This.Width - 5
				This.Top = m.oGrid.Top - This.Height - 2
				This.Anchor = 9
			EndIf
		EndIf
		
	ENDPROC

	PROCEDURE LostFocus
		If This.InvisibleOnLostFocus
			This.Visible = This.AlwaysVisible
		EndIf
		
	ENDPROC

	PROCEDURE MouseEnter
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		This._MouseActivation = .t.
		This.Active = .t.
		
	ENDPROC

	PROCEDURE MouseLeave
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		If This._MouseActivation
			This.Active = .f.
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE visible_assign
		Lparameters vNewVal
		
		This.Visible = This.AlwaysVisible or m.vNewVal
		If m.vNewVal
			This.txtFind.SetFocus()
		Else
			if (Vartype(This.oObject) = 'O') ;
				and (Type('This.oObject.oGrid') = 'O')
			
				This.txtFind.Value = ''
				This._OldFindText = ''
				This.oObject.oGrid.SetFocus()
			EndIf
		EndIf
		
	ENDPROC

	PROCEDURE _find		&& Main find method.
		Lparameters nOrder As Integer, lReset As Logical
		
		If (Vartype(This.oObject) = 'O') ;
			and (Type('This.oObject.oGrid') = 'O') ;
			and not Empty(This.txtFind.Value)
			
			Local nFlags As Integer, ;
					cText As Integer
			
			m.nFlags = 0
			m.nFlags = m.nFlags + 2^0 * Iif((This._OldFindText == This.txtFind.Value), 0, 1)	&& Reset.
		
			If (Lower(This.oObject.Class) = 'mngrgrid') ;
				and (This.oObject.ActiveSortOrder == 'DES')
		
				*-- Si el sort order es DESC debemos de cambiar el sentido de funcionamiento.
				m.nOrder = Iif(m.nOrder = 0, 1, 0)
				m.nFlags = m.nFlags + 2^5														&& Reversed.
			EndIf
			m.nFlags = m.nFlags + 2^1 * Iif((m.nOrder = 1), 1, 0)								&& Order, 0 - ASC, 1 - DES.
		
			m.nFlags = m.nFlags + 2^2 * Iif(This.txtFind.Value = '^', 1, 0)						&& Start or contains text.
			m.nFlags = m.nFlags + 2^3 * Iif(This.txtFind.Value = '=', 1, 0)						&& Exact on.
			
			m.cText = Alltrim(This.txtFind.Value)
			If (m.cText = '$') or (cText = '^') or (This.txtFind.Value = '=') ;
				or (m.cText = '\$') or (cText = '\^') or (This.txtFind.Value = '\=') ;
				
				m.cText = Substr(m.cText, 2)
			EndIf
		
			This.InvisibleOnLostFocus = .f.
			This.oObject.OnFind(m.cText, m.nFlags)
			This._OldFindText = This.txtFind.Value
			This.InvisibleOnLostFocus = .t.
			Doevents
		EndIf
		
	ENDPROC

	PROCEDURE _mouseactivation_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		THIS._MouseActivation = m.vNewVal
		
	ENDPROC

	PROCEDURE cmdNext.KeyPress
		Lparameters nKeyCode, nShiftAltCtrl
		
		If not This.Parent.Active
			Return 
		EndIf
		
		Do case
			Case (m.nKeyCode = 9) && TAB
				NoDefault
				
			Case (m.nKeyCode = 15) && Shift+TAB
				NoDefault
				
			Case (m.nKeyCode = 27) && ESC
				This.Parent.Visible = .f.
				NoDefault
		
			Case (not Empty(This.Parent.FindNextKey) ;
				and (m.nKeyCode = This.Parent.FindNextKey))
				
				This.Parent._Find(0)
				NoDefault
		
			Case (not Empty(This.Parent.FindPreviousKey) ;
				and (m.nKeyCode = This.Parent.FindPreviousKey))
				
				This.Parent._Find(1)
				NoDefault
						
		EndCase
		
	ENDPROC

	PROCEDURE cmdNext.When
		Local lResult As Logical
		
		If This.Parent.Active
			m.lResult = .t.
			This.Parent._MouseActivation = .f. && Deactivate mouse activation flag.
		Else
			m.lResult = .f.
		EndIf
		
		Return m.lResult
		
	ENDPROC

	PROCEDURE cmdPrevious.KeyPress
		Lparameters nKeyCode, nShiftAltCtrl
		
		If not This.Parent.Active
			Return 
		EndIf
		
		Do case
			Case (m.nKeyCode = 9) && TAB
				NoDefault
				
			Case (m.nKeyCode = 15) && Shift+TAB
				NoDefault
				
			Case (m.nKeyCode = 27) && ESC
				This.Parent.Visible = .f.
				NoDefault
		
			Case (not Empty(This.Parent.FindNextKey) ;
				and (m.nKeyCode = This.Parent.FindNextKey))
				
				This.Parent._Find(0)
				NoDefault
				
			Case (not Empty(This.Parent.FindPreviousKey) ;
				and (m.nKeyCode = This.Parent.FindPreviousKey))
				
				This.Parent._Find(1)
				NoDefault
						
		EndCase
		
	ENDPROC

	PROCEDURE cmdPrevious.When
		Local lResult As Logical
		
		If This.Parent.Active
			m.lResult = .t.
			This.Parent._MouseActivation = .f. && Deactivate mouse activation flag.
		Else
			m.lResult = .f.
		EndIf
		
		Return m.lResult
		
	ENDPROC

	PROCEDURE txtFind.KeyPress
		Lparameters nKeyCode, nShiftAltCtrl
		
		If not This.Parent.Active
			Return 
		EndIf
		
		Do case
			Case (m.nKeyCode = 9) && TAB
				NoDefault
				
			Case (m.nKeyCode = 15) && Shift+TAB
				NoDefault
				
			Case (m.nKeyCode = 27) && ESC
				This.Parent.Visible = .f.
				NoDefault
		
			Case (m.nKeyCode = 13) && ENTER
				This.Parent._Find(0)
				NoDefault
				
			Case (not Empty(This.Parent.FindNextKey) ;
				and (m.nKeyCode = This.Parent.FindNextKey))
				
				This.Parent._Find(0)
				NoDefault
		
			Case (not Empty(This.Parent.FindPreviousKey) ;
				and (m.nKeyCode = This.Parent.FindPreviousKey))
				
				This.Parent._Find(1)
				NoDefault
						
			Otherwise
			
		EndCase
		
	ENDPROC

	PROCEDURE txtFind.When
		Local lResult As Logical
		
		If This.Parent.Active
			m.lResult = .t.
			This.Parent._MouseActivation = .f. && Deactivate mouse activation flag.
		Else
			m.lResult = .f.
		EndIf
		
		Return m.lResult
		
	ENDPROC

ENDDEFINE

DEFINE CLASS mngrgrid AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="pictures\mngrgrid16x16.png" ClassIcon="pictures\mngrgrid16x16.png" />

	*<DefinedPropArrayMethod>
		*m: activesortcolumn_access
		*m: activesortcolumn_assign
		*m: activesortorder_access
		*m: activesortorder_assign
		*m: alternaterowcolorenabled_assign
		*m: autosizecolumnsenabled_assign
		*m: autosizecolumnsmode_assign
		*m: autosizecolumns_assign
		*m: dynamicpropertiesmode_assign
		*m: enabled_assign
		*m: findboxalwaysvisible_assign
		*m: findenabled_assign
		*m: footercolumns_assign
		*m: footerenabled_assign
		*m: ogrid_access
		*m: ogrid_assign
		*m: oncolumnsort		&& Column sort event. This even receives ControlSource as first parameter and, as second parameter,  'ASC' for ascending sort or 'DES' for descending sort. Event must Return .t. on success and .f. on fail.
		*m: onfind		&& On find event.
		*m: ongridheaderclick		&& Grid Header Click event.
		*m: restoresources		&& Restore a saved grid recordsource and controlsource of all columns.
		*m: savesources		&& Save the grid recordsource and controlsource of all columns.
		*m: savprefix_assign
		*m: sortcolumns_assign
		*m: sortenabled_assign
		*m: _bindobject		&& Establece el vínculo con el objeto de tipo Grid indicado en la propiedad oGrid.
		*m: _iscolumnautosizable		&& Returns .t. if column index passed as parameter is autosizable, otherwise returns .f..
		*m: _iscolumnsortable		&& Returns .t. if column is indicated in SortColumns property, otherwise returns .f..
		*m: _ongridheaderclick		&& Hidden Grid Header Click event.
		*m: _ongridkeypress		&& Grid keypress event.
		*m: _ongridmousedown		&& Grid MouseDown event.
		*m: _ongridresize		&& Grid Resize event.
		*m: _setalternaterowcolor		&& Set or reset AlternateRowColor.
		*m: _setautosizecolumns		&& Set or reset auto size columns.
		*m: _setfind		&& Set or reset find box.
		*m: _setsort		&& Set or reset column header sort.
		*m: _setsortcolumn		&& Set column header passed as parameter as current sort column. If no header is passed then no header is setted.
		*m: _unbindobject		&& Si el componente está vinculado lo desvincula.
		*p: activesortcolumn		&& Store the active sort column object.
		*p: activesortorder		&& Store the active sort order.
		*p: alternaterowcolorenabled		&& Alternates row color using properties AlternateRowColorOdd and AlternateRowColorEven. When this is enabled changing other properties forces a SetFocus() to associated grid.
		*p: alternaterowcoloreven		&& Even row color
		*p: alternaterowcolorodd		&& Odd rows color
		*p: autosizecolumns		&& Comma-separated column names associated with AutosizeColumnsMode. Empty means all columns.
		*p: autosizecolumnsenabled		&& Enable or disable autosize columns.
		*p: autosizecolumnsmode		&& 0 - AutoSize all columns, 1- AutoSize all columns except columns in AutoSizeColumns, 2 - AutoSize only columns in AutoSizeColumns
		*p: dynamicpropertiesmode		&& 0 - Rude, 1 - Polite, 2 - Respectful
		*p: findboxalwaysvisible		&& Set find box as always visible.
		*p: findenabled		&& Enable or disable find box.
		*p: findkey		&& Hotkey to activate find box. See Inkey() help for keycodes.
		*p: findnextkey		&& Hotkey to find next. See Inkey() help for keycodes.
		*p: findpreviouskey		&& Hotkey to find previous. See Inkey() help for keycodes.
		*p: footercolumns		&& Comma-separated list of columns to display in footer. This property can't be changed when FooterEnabled is enabled.
		*p: footerenabled		&& Enable or disable footer.
		*p: ogrid		&& Associated grid. RO in runtime.
		*p: picturesortascending		&& Picture for ascending sort.
		*p: picturesortdescending		&& Picture for descending sort.
		*p: savprefix		&& Saved properties prefix. RO in runtime.
		*p: sortcolumns		&& Comma-separated list of column names, first column is default sort. If empty all columns are sortable. This property can't be changed when SortEnabled is enabled.
		*p: sortenabled		&& Enable or disable column header sort mode.
		*p: supportedclasslist		&& Comma-separated names of supported classes.
		*p: uuid		&& uuid.
		*p: _cgrid		&& Grid name cache.
		*p: _classlibsetted		&& Flag to store if classlib Managers was setted or not.
		*p: _findactive		&& If .t. then find box is visible, otherwise is not visible.
		*p: _ogrid		&& Grid object cache.
	*</DefinedPropArrayMethod>

	HIDDEN ActiveControl,AddObject,AddProperty,BackColor,BackStyle,BorderColor,BorderWidth,Click,CloneObject,ColorSource,ControlCount,Controls,DblClick,Destroy,DragDrop,DragIcon,DragMode,DragOver,Drag,Draw,ForeColor,GotFocus,HelpContextID,Init,LostFocus,MiddleClick,MouseDown,MouseEnter,MouseIcon,MouseLeave,MouseMove,MousePointer,MouseUp,MouseWheel,Moved,Move,NewObject,Objects,OLECompleteDrag,OLEDragDrop,OLEDragMode,OLEDragOver,OLEDragPicture,OLEDrag,OLEDropEffects,OLEDropHasData,OLEDropMode,OLEGiveFeedback,OLESetData,OLEStartDrag,ParentClass,Parent,Picture,ReadExpression,ReadMethod,Refresh,RemoveObject,ResetToDefault,Resize,RightClick,SaveAsClass,savprefix,SetAll,SetFocus,ShowWhatsThis,SpecialEffect,StatusBarText,Style,TabIndex,TabStop,ToolTipText,UIEnable,Visible,WhatsThisHelpID,WriteExpression,WriteMethod,ZOrder,_classlibsetted,_ogrid
	PROTECTED Height,Width
	activesortcolumn = 		&& Store the active sort column object.
	activesortorder = 		&& Store the active sort order.
	alternaterowcolorenabled = .T.		&& Alternates row color using properties AlternateRowColorOdd and AlternateRowColorEven. When this is enabled changing other properties forces a SetFocus() to associated grid.
	alternaterowcoloreven = Rgb(220, 220, 250)		&& Even row color
	alternaterowcolorodd = Rgb(200, 200, 250)		&& Odd rows color
	autosizecolumns = 		&& Comma-separated column names associated with AutosizeColumnsMode. Empty means all columns.
	autosizecolumnsenabled = .T.		&& Enable or disable autosize columns.
	autosizecolumnsmode = 0		&& 0 - AutoSize all columns, 1- AutoSize all columns except columns in AutoSizeColumns, 2 - AutoSize only columns in AutoSizeColumns
	BackColor = 0,0,0
	BackStyle = 1
	BorderColor = 0,0,0
	BorderWidth = 1
	dynamicpropertiesmode = 2		&& 0 - Rude, 1 - Polite, 2 - Respectful
	findboxalwaysvisible = .F.		&& Set find box as always visible.
	findenabled = .T.		&& Enable or disable find box.
	findkey = 6		&& Hotkey to activate find box. See Inkey() help for keycodes.
	findnextkey = -2		&& Hotkey to find next. See Inkey() help for keycodes.
	findpreviouskey = 86		&& Hotkey to find previous. See Inkey() help for keycodes.
	footercolumns = 		&& Comma-separated list of columns to display in footer. This property can't be changed when FooterEnabled is enabled.
	footerenabled = .F.		&& Enable or disable footer.
	Height = 25
	Name = "mngrgrid"
	ogrid = 		&& Associated grid. RO in runtime.
	Picture = pictures\mngrgrid.png
	picturesortascending = Pictures\MngrGridSortAscending.bmp		&& Picture for ascending sort.
	picturesortdescending = Pictures\MngrGridSortDescending.bmp		&& Picture for descending sort.
	savprefix = _Sav_		&& Saved properties prefix. RO in runtime.
	sortcolumns = 		&& Comma-separated list of column names, first column is default sort. If empty all columns are sortable. This property can't be changed when SortEnabled is enabled.
	sortenabled = .T.		&& Enable or disable column header sort mode.
	SpecialEffect = 0
	supportedclasslist = Grid		&& Comma-separated names of supported classes.
	TabStop = .F.
	uuid = 26ea386b-1569-4526-a6c4-edf45379c9ee		&& uuid.
	Visible = .F.
	Width = 25
	_cgrid = 		&& Grid name cache.
	_classlibsetted = .F.		&& Flag to store if classlib Managers was setted or not.
	_findactive = .F.		&& If .t. then find box is visible, otherwise is not visible.
	_ogrid = .F.		&& Grid object cache.
	
	HIDDEN PROCEDURE activesortcolumn_access
		Local oResult As Object, ;
			oGrid As Grid, ;
			oColumn As Column
			
		m.oResult = .f.
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O')
			*-- Buscamos los header.
			For Each m.oColumn As Column In m.oGrid.Columns
				If (Type('m.oColumn._SortOrder') = 'C') ;
					and not Empty(m.oColumn._SortOrder)
					
					m.oResult = m.oColumn
					Exit
				EndIf
			EndFor
		EndIf
		
		Return m.oResult
		
	ENDPROC

	HIDDEN PROCEDURE activesortcolumn_assign
		Lparameters vNewVal
		
		*-- Calculated value.
		
	ENDPROC

	HIDDEN PROCEDURE activesortorder_access
		Local cResult As String, ;
			oGrid As Grid, ;
			oColumn As Column
			
		m.cResult = ''
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O')
			*-- Buscamos los header.
			For Each m.oColumn As Column In m.oGrid.Columns
				If (Type('m.oColumn._SortOrder') = 'C') ;
					and not Empty(m.oColumn._SortOrder)
					
					m.cResult = m.oColumn._SortOrder
					Exit
				EndIf
			EndFor
		EndIf
		
		Return m.cResult
		
	ENDPROC

	HIDDEN PROCEDURE activesortorder_assign
		Lparameters vNewVal
		
		*-- Calculated value.
		
	ENDPROC

	HIDDEN PROCEDURE alternaterowcolorenabled_assign
		Lparameters vNewVal
		
		If This.Enabled
			Local oGrid As Grid
		
			m.oGrid = This.oGrid
			If (Vartype(m.oGrid) = 'O') ;
				and (m.vNewVal <> This.AlternateRowColorEnabled)
		
				This._SetAlternateRowColor(m.vNewVal)
				This.AlternateRowColorEnabled = m.vNewVal
			EndIf
		Else
			This.AlternateRowColorEnabled = m.vNewVal
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE autosizecolumnsenabled_assign
		Lparameters vNewVal
		
		If This.Enabled
			Local oGrid As Grid
		
			m.oGrid = This.oGrid
			If (Vartype(m.oGrid) = 'O') ;
				and (m.vNewVal <> This.AutoSizeColumnsEnabled)
		
				If This._SetAutoSizeColumns(m.vNewVal)
					This.AutoSizeColumnsEnabled = m.vNewVal
					If m.vNewVal
						This._OnGridResize()
					EndIf
				EndIf
			EndIf
		Else
			This.AutoSizeColumnsEnabled = m.vNewVal
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE autosizecolumnsmode_assign
		Lparameters vNewVal
		
		This.AutoSizeColumnsMode = Iif((Vartype(m.vNewVal) = 'N') and InList(m.vNewVal, 0, 1, 2), m.vNewVal, 0)
		If This.Enabled
			This._OnGridResize()
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE autosizecolumns_assign
		Lparameters vNewVal
		
		This.AutoSizeColumns = m.vNewVal
		If This.Enabled
			This._OnGridResize()
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE Destroy
		*-- Desenlazamos el objeto de la grid asociada.
		This._UnBindObject()
		
		If This._ClassLibSetted
			Release Classlib Managers
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE dynamicpropertiesmode_assign
		Lparameters vNewVal
		
		If (Vartype(m.vNewVal) = 'N') and InList(m.vNewVal, 0, 1, 2)
			*-- 0 - Rude        -- all previous values are overwriten.
			*-- 1 - Polite		-- all previous values are saved and restored.
			*-- 2 - Respectful	-- all previous values are respected.
			This.DynamicPropertiesMode = m.vNewVal
			If This.AlternateRowColorEnabled
				This._SetAlternateRowColor(.f.)	&& Deactivate.
				This._SetAlternateRowColor(.t.)	&& Activate again.
			EndIf
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE enabled_assign
		Lparameters vNewVal
		
		*-- Evitamos cambios concurrentes.
		If (m.vNewVal <> This.Enabled)
			If m.vNewVal
				This.Enabled = m.vNewVal
				This._BindObject()
			Else
				This._UnBindObject()
				This.Enabled = m.vNewVal
			EndIf
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE findboxalwaysvisible_assign
		Lparameters vNewVal
		
		If not This.FindEnabled
			*-- Can't change if FindEnabled is active.
			This.FindBoxAlwaysVisible = m.vNewVal
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE findenabled_assign
		Lparameters vNewVal
		
		If This.Enabled
			Local oGrid As Grid
		
			m.oGrid = This.oGrid
			If (Vartype(m.oGrid) = 'O') ;
				and (m.vNewVal <> This.FindEnabled)
		
				If This._SetFind(m.vNewVal)
					This.FindEnabled = m.vNewVal
				EndIf
			EndIf
		Else
			This.FindEnabled = m.vNewVal
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE footercolumns_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		*TODO: Basarse en SortColumns_assign
		THIS.footercolumns = m.vNewVal
		
	ENDPROC

	HIDDEN PROCEDURE footerenabled_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		*TODO: basarse en SortEnabled_assign.
		THIS.footerenabled = m.vNewVal
		
	ENDPROC

	HIDDEN PROCEDURE Init
		*-- Si no se ha hecho el Set Classlib hay que hacerlo.
		If (At('\MANAGERS.VCX ', Set('Classlib')) <= 0)
			Set Classlib To Managers Additive
			This._ClasslibSetted = .t.
		Else
			This._ClasslibSetted = .f.
		EndIf
		
		*-- Si el control está habilitado llamamos lo enlazamos.
		Return not This.Enabled or This._BindObject()
		
	ENDPROC

	HIDDEN PROCEDURE ogrid_access
		Local oGrid As Grid
		
		If not This.Enabled
			Return 
		EndIf
		
		If (Vartype(This._oGrid) = 'O')
			m.oGrid = This._oGrid
		Else
			Try
				m.oGrid = Iif((Vartype(This.oGrid) = 'C') and not Empty(This.oGrid), Evaluate(This.oGrid), .f.)
			Catch
				*-- Ignore.
			EndTry
		
			If (Vartype(m.oGrid) <> 'O') or (At(',' + Upper(m.oGrid.BaseClass) + ',', ',' + Upper(Alltrim(ChrTran(This.SupportedClassList, ' ', ''))) + ',') = 0)
				m.oGrid = .f.
				This._oGrid = m.oGrid
				This._cGrid = ''
			Else
				This._oGrid = m.oGrid
				This._cGrid = This.oGrid
			EndIf
		EndIf
		
		Return m.oGrid
		
	ENDPROC

	HIDDEN PROCEDURE ogrid_assign
		LParameters vNewVal
		
		*-- ReadOnly on Runtime.
		
	ENDPROC

	PROCEDURE oncolumnsort		&& Column sort event. This even receives ControlSource as first parameter and, as second parameter,  'ASC' for ascending sort or 'DES' for descending sort. Event must Return .t. on success and .f. on fail.
		Lparameters cControlSource As String, cSortOrder As String && cSortOrder = < ASC | DES >, Return 0 - Sort&Order, 1 - Only Sort, -1 - Fail
		
	ENDPROC

	PROCEDURE onfind		&& On find event.
		Lparameters cText As String, nFlags As Integer
		
	ENDPROC

	PROCEDURE ongridheaderclick		&& Grid Header Click event.
		Lparameters oColumn As Column
		
		This._OnGridHeaderClick(m.oColumn)
		
	ENDPROC

	PROCEDURE restoresources		&& Restore a saved grid recordsource and controlsource of all columns.
		Lparameters lNotRemoveSaved As Logical
		
		If not This.Enabled
			Return 
		EndIf
		
		Local oGrid As Grid, ;
			i As Integer
			
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O') ;
			and (Type('m.oGrid.' + This.SavPrefix + 'RecordSource') <> 'U')
			
			m.oGrid.RecordSource = Evaluate('m.oGrid.' + This.SavPrefix + 'RecordSource')
			For m.i = 1 To m.oGrid.ColumnCount 
				m.oGrid.Columns(m.i).ControlSource = Evaluate('m.oGrid.Columns(m.i).' + This.SavPrefix + 'ControlSource')
			EndFor
		
			If not m.lNotRemoveSaved
				RemoveProperty(m.oGrid, This.SavPrefix + 'RecordSource')
				For m.i = 1 To m.oGrid.ColumnCount 
					RemoveProperty(m.oGrid.Columns(m.i), This.SavPrefix + 'ControlSource')
				EndFor
			EndIf 
		EndIf
		
		If This.AlternateRowColorEnabled
			m.oGrid.SetFocus()	&& Wrong refresh unless grid has focus. Use 'Help ActiveRow' for more info.
		EndIf
		
	ENDPROC

	PROCEDURE savesources		&& Save the grid recordsource and controlsource of all columns.
		Lparameters lNotCleanBinding As Logical
		
		If not This.Enabled
			Return 
		EndIf
		
		Local oGrid As Grid, ;
			cProperty As String, ;
			lMustRemoveProperties As Logical, ;
			i As Integer
		
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O') ;
			and not Empty(m.oGrid.RecordSource)
			
			m.cProperty = This.SavPrefix + 'RecordSource'
			m.lMustRemoveProperties = (Type('m.oGrid.' + m.cProperty) <> 'U')
			If m.lMustRemoveProperties
				RemoveProperty(m.oGrid, m.cProperty)
			EndIf
			m.oGrid.AddProperty(m.cProperty, m.oGrid.RecordSource)
			
			For m.i = 1 to m.oGrid.ColumnCount
				m.cProperty = This.SavPrefix + 'ControlSource'
				If m.lMustRemoveProperties
					RemoveProperty(m.oGrid.Columns(m.i), m.cProperty)
				EndIf
				m.oGrid.Columns(m.i).AddProperty(m.cProperty, m.oGrid.Columns(m.i).ControlSource)
			EndFor
		
			If not m.lNotCleanBinding 
				m.oGrid.RecordSource = ''
			EndIf
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE savprefix_assign
		Lparameters vNewVal
		
		*-- Read Only on runtime.
		
	ENDPROC

	HIDDEN PROCEDURE sortcolumns_assign
		Lparameters vNewVal
		
		If not This.SortEnabled
			*-- Can't change if SortEnabled is active.
			This.SortColumns = m.vNewVal
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE sortenabled_assign
		Lparameters vNewVal
		
		If This.Enabled
			Local oGrid As Grid
		
			m.oGrid = This.oGrid
			If (Vartype(m.oGrid) = 'O') ;
				and (m.vNewVal <> This.SortEnabled)
		
				This._SetSort(m.vNewVal)
				This.SortEnabled = m.vNewVal
			EndIf
		Else
			This.SortEnabled = m.vNewVal
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE _bindobject		&& Establece el vínculo con el objeto de tipo Grid indicado en la propiedad oGrid.
		Local oGrid As Grid
		
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O')
			If This.AlternateRowColorEnabled
				This._SetAlternateRowColor(.t.)
			EndIf
			If This.FindEnabled
				This._SetFind(.t.)
			EndIf
			If This.SortEnabled
				This._SetSort(.t.)
			EndIf
			If This.AutoSizeColumnsEnabled
				This._SetAutoSizeColumns(.t.)
				This._OnGridResize()
			EndIf
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE _iscolumnautosizable		&& Returns .t. if column index passed as parameter is autosizable, otherwise returns .f..
		Lparameters oGrid As Grid, ;
			nColumnIndex As Integer
		
		Local lResult As Logical
		
		Do case
			Case (This.AutoSizeColumnsMode = 1)
				*-- All except AutoSizeColumns
				If Empty(This.AutoSizeColumns)
					m.lResult = .f.
				Else
					m.lResult = (At(',' + Upper(m.oGrid.Columns(m.i).Name) + ',', ',' + Chrtran(Upper(Alltrim(This.AutoSizeColumns)), ' ', '') + ',') = 0)
				EndIf
			
			Case (This.AutoSizeColumnsMode = 2)
				*-- Only AutoSizeColumns
				If Empty(This.AutoSizeColumns)
					m.lResult = .t.
				Else
					m.lResult = (At(',' + Upper(m.oGrid.Columns(m.i).Name) + ',', ',' + Chrtran(Upper(Alltrim(This.AutoSizeColumns)), ' ', '') + ',') > 0)
				EndIf
			
			Otherwise
				*-- All columns.
				m.lResult = .t.
		
		EndCase
		
		Return m.lResult
		
	ENDPROC

	HIDDEN PROCEDURE _iscolumnsortable		&& Returns .t. if column is indicated in SortColumns property, otherwise returns .f..
		Lparameters oGrid As Grid, ;
			 nColumnIndex As Integer
		
		Local lResult As Boolean
		
		If Empty(This.SortColumns)
			m.lResult = .t.
		else
			m.lResult = (At(',' + Upper(m.oGrid.Columns(m.nColumnIndex).Name) + ',', ',' + Chrtran(Upper(Alltrim(This.SortColumns)), ' ', '') + ',') > 0)
		EndIf
			
		Return m.lResult
		
	ENDPROC

	HIDDEN PROCEDURE _ongridheaderclick		&& Hidden Grid Header Click event.
		Lparameters cColumnName As String
		
		Local oGrid As Grid, ;
			oColumn As Column, ;
			lColumnChange As Logical, ;
			cNewSortOrder As String, ;
			nOldRecno As Integer, ;
			nResult As Integer
		
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O')
			For Each m.oColumn In m.oGrid.Columns
				If (m.oColumn.Name == cColumnName)
					m.cNewSortOrder = Iif(Empty(m.oColumn._SortOrder) or (m.oColumn._SortOrder = 'DES'), 'ASC', 'DES')
					m.nOldRecno = Iif(Eof(m.oGrid.RecordSource), 0, Recno(m.oGrid.RecordSource))
					m.nResult = This.OnColumnSort(m.oColumn.ControlSource, m.cNewSortOrder)
					m.nResult = Iif((Vartype(nResult) <> 'N') or not InList(m.nResult, 0, 1), -1, m.nResult)
					Do case
						Case (m.nResult = 0)
							m.oColumn._SortOrder = m.cNewSortOrder
							This._SetSortColumn(m.oColumn)
							m.oGrid.Refresh()
		
						Case (m.nResult = 1)
							This._SetSortColumn(m.oColumn)
							m.oGrid.Refresh()
		
						Otherwise && (nResult = -1)
							*-- Nada.
					EndCase
					If (m.nOldRecno <> 0) ;
						and (Recno(m.oGrid.RecordSource) <> m.nOldRecno)
						
						Go (m.nOldRecno) ;
							In (m.oGrid.RecordSource)
					EndIf
				EndIf
			EndFor
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE _ongridkeypress		&& Grid keypress event.
		Lparameters nKeyCode, nShiftAltCtrl
		
		Local oGrid As Grid
		
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O') ;
			and This.FindEnabled ;
			and (Type('Thisform._oFindBox') = 'O')
		
			*-- Procesamos las keys del grid.
			If Thisform._oFindBox.Active
				Do case
					Case (m.nKeyCode = 9) && TAB
						NoDefault
						
					Case (m.nKeyCode = 15) && Shift+TAB
						NoDefault
						
					Case (m.nKeyCode = 27) && ESC
						Thisform._oFindBox.Visible = .f.
						Thisform._oFindBox.Active = .f.
						NoDefault
		
					Case (m.nKeyCode = 13) && ENTER
						Thisform._oFindBox._Find(0)
						NoDefault
		
					Case (m.nKeyCode = This.FindKey)
						Thisform._oFindBox.Visible = .t.
						Thisform._oFindBox.Active = .t.
						Thisform._oFindBox.txtFind.SetFocus()
						NoDefault
						
					Case (not Empty(This.FindNextKey) ;
						and (m.nKeyCode = This.FindNextKey))
		
						Thisform._oFindBox._Find(0)
						NoDefault
		
					Case (not Empty(This.FindPreviousKey) ;
						and (m.nKeyCode = This.FindPreviousKey))
						
						Thisform._oFindBox._Find(1)
						NoDefault
		
					Otherwise
						Thisform._oFindBox.txtFind.SetFocus()
		
						*-- We need to relaunch some keys to avoid losing them
						*-- because there is a Dodefault to avoid the active
						*-- control to process the key press.
						*-- Key press codes greater than 255 will be lost.
						Do case
							Case (m.nKeyCode = 19)
								Keyboard '{LEFTARROW}'
							Case (m.nKeyCode = 127)
								Keyboard '{BACKSPACE}'
							Case Between(m.nKeyCode, 32, 255)
								Keyboard Chr(m.nKeycode)
							Otherwise
								*-- Key press lost.
								Keyboard Chr(m.nKeycode)
						EndCase
						NoDefault
					
				EndCase
		
			Else
		
				Do case
					Case (m.nKeyCode = This.FindKey)
						Thisform._oFindBox.Visible = .t.
						Thisform._oFindBox.Active = .t.
						Thisform._oFindBox.txtFind.SetFocus()
						NoDefault
						
					*Otherwise
						*-- Nada.
				EndCase
			EndIf
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE _ongridmousedown		&& Grid MouseDown event.
		Lparameters nButton, nShift, nXCoord, nYCoord
		
		Local oGrid As Grid, ;
			nWhere_Out As Integer
			
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O')
			m.nWhere_Out = 0
			m.oGrid.GridHitTest(m.nXCoord, m.nYCoord, @nWhere_Out)
			If (m.nWhere_Out = 11)	&& Click on grid upper left rectangle.
				This._OnGridResize()
			EndIf
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE _ongridresize		&& Grid Resize event.
		Local oGrid As Grid
		
		m.oGrid = This.oGrid
		
		If (Vartype(m.oGrid) <> 'O')
			Return
		EndIf
		
		Local Old_nWhere_Out As Integer, ;
				nLeftFirstColumn AS Integer, ;
				nLeftEnd As Integer, ;
				nWhere_Out As Integer, ;
				nRelRow_Out As Integer, ;
				nRelCol_Out As Integer, ;
				nView_Out As Integer, ;
				lResizable As Logical, ;
				nResizableColumnCount As Integer, ;
				nViewWidth As Integer, ;
				nColumnWidth As Integer, ;
				nFixedColumnsWidth AS Integer, ;
				nColumnWidthRemanent As Integer, ;
				nNewWidth As Integer
		
		*-- Calculamos la posición de la primera columna y del final del gri.
		m.Old_nWhere_Out = -1
		m.nLeftFirstColumn = -1
		m.nLeftEnd = m.oGrid.Left + m.oGrid.Width && Incializamos al largo más la posición izquierda.
		For m.i = 1 To m.oGrid.Width
			m.nWhere_Out = 0
			m.nRelRow_Out = 0
			m.nRelCol_Out = 0
			m.nView_Out = 0
			m.x = m.oGrid.Left + m.i
			m.y = m.oGrid.Top + Int(m.oGrid.HeaderHeight/2)
			m.oGrid.GridHitTest(m.x, m.y, @m.nWhere_Out, @m.nRelRow_Out, @m.nRelCol_Out, @m.nView_Out)
			If (m.Old_nWhere_Out <> m.nWhere_Out)
				m.Old_nWhere_Out = m.nWhere_Out
				Do case
					Case (m.nWhere_Out = 1)		&& 1 - Column header.
		 
						If (m.nLeftFirstColumn = -1)
							m.nLeftFirstColumn = m.x
						EndIf
						
					Case (m.nWhere_Out = 17)	&& 17 - Vertical scrollbar. 
		 				m.nLeftEnd = m.x
		
					*Otherwise
						*-- Nada.				
				EndCase
			EndIf
		EndFor
		
		*-- Si se ha activado la split view no hacemos ningún cálculo.
		If (m.oGrid.View = 0) and (m.oGrid.Partition = 0)
			*-- Visible y Resizable y AutoSizable columns.
			m.nResizableColumnCount = 0
			m.nFixedColumnsWidth = 0
			For m.i = 1 To m.oGrid.ColumnCount
				m.lResizable = m.oGrid.Columns(m.i).Resizable and This._IsColumnAutoSizable(m.oGrid, m.i)
				If m.oGrid.Columns(m.i).Visible
					If m.lResizable
						m.nResizableColumnCount = m.nResizableColumnCount + 1
					Else
						*-- Si no es resizable añadimos su width para restarlo.
						m.nFixedColumnsWidth = m.nFixedColumnsWidth + m.oGrid.Columns(m.i).Width + m.oGrid.GridLineWidth
					EndIf
				EndIf
			EndFor
		
			m.nViewWidth = m.nLeftEnd - m.nLeftFirstColumn - (m.oGrid.ColumnCount * m.oGrid.GridLineWidth) - m.nFixedColumnsWidth
			*-- Si hay columnas que puedan cambiar de tamaño y el grid tiene un tamaño mínimo procedemos.
			If (m.nResizableColumnCount > 0) and (m.nViewWidth > m.nResizableColumnCount * 5)
			
				*-- Calculamos el Width que vamos a aplicar a cada columna.
				m.nColumnWidth = Int(m.nViewWidth / m.nResizableColumnCount)
				*-- Calculamos lo que nos sobra para asignarlo también.
				m.nColumnWidthRemanent = Max(m.nViewWidth - 1 - (m.nColumnWidth * m.nResizableColumnCount), 0)
				
				*-- Cambiamos el tamaño de las columnas AutoSizable.
				For m.i = 1 To m.oGrid.ColumnCount
					If m.oGrid.Columns(m.i).Visible ;
						and m.oGrid.Columns(m.i).Resizable ;
						and This._IsColumnAutoSizable(m.oGrid, m.i)
						
						If (nColumnWidthRemanent > 0)
							m.nNewWidth = m.nColumnWidth + 1
							m.nColumnWidthRemanent = m.nColumnWidthRemanent - 1
						Else
							m.nNewWidth = m.nColumnWidth
						EndIf
						m.oGrid.Columns(m.i).Width = m.nNewWidth
					EndIf
				EndFor
				
				*-- Si queda algún remanente se lo añadimos a la última columna AutoSizable.
				If (m.nColumnWidthRemanent > 0)
					For m.i = m.oGrid.ColumnCount To 1 Step -1
						If m.oGrid.Columns(m.i).Visible and m.oGrid.Columns(m.i).Resizable
							m.oGrid.Columns(m.i).Width = m.oGrid.Columns(m.i).Width + m.nColumnWidthRemanent
							Exit
						EndIf
					EndFor
				EndIf
				
			EndIf
		EndIf
		
		If This.AlternateRowColorEnabled
			m.oGrid.SetFocus()	&& Wrong refresh unless grid has focus. Use 'Help ActiveRow' for more info.
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE _setalternaterowcolor		&& Set or reset AlternateRowColor.
		Lparameters lSetAlternateRowColor
		
		*-- DynamicPropertiesMove supported values:
		*-- 0 - Rude        -- all previous values are overwriten.
		*-- 1 - Polite		-- all previous values are saved and restored.
		*-- 2 - Respectful	-- all previous values are respected.
		
		Local oGrid As Grid, ;
			cSavProperty As String, ;
			lSavExists As Logical, ;
			i As Integer, ;
			cNewDynamicBackColor As String
		
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O')
			m.cSavProperty = This.SavPrefix + 'DynamicBackColor'
			If m.lSetAlternateRowColor
				*-- No se puede hacer un SetAll().
				*m.oGrid.SetAll('DynamicBackColor', 'Iif(' + This._cGrid + '.ActiveRow % 2 = 0, ' + This.AlternateRowColorOdd + ', ' + This.AlternateRowColorEven + ')', 'Column')
				If (m.oGrid.ColumnCount > 0)
					m.lSavExists = (Type('m.oGrid.Columns(1).' + m.cSavProperty) = 'C')
					For m.i = 1 To m.oGrid.ColumnCount
						If m.lSavExists
							RemoveProperty(m.oGrid.Columns(m.i), m.cSavProperty)
						EndIf
						
						m.cNewDynamicBackColor = 'Iif(' + This._cGrid + '.ActiveRow % 2 = 0, ' + This.AlternateRowColorOdd + ', ' + This.AlternateRowColorEven + ')'
						Do case
							Case (This.DynamicPropertiesMode = 1)
								*-- Polite.
								m.oGrid.Columns(m.i).AddProperty(m.cSavProperty, m.oGrid.Columns(m.i).DynamicBackColor)
							Case (This.DynamicPropertiesMode = 2)
								*-- Respectful.
								m.oGrid.Columns(m.i).AddProperty(m.cSavProperty, m.oGrid.Columns(m.i).DynamicBackColor)
								If not Empty(m.oGrid.Columns(m.i).DynamicBackColor)
									m.cNewDynamicBackColor = ''
								EndIf
							Otherwise && (This.DynamicPropertiesMode = 0)
								*-- Rude.
								m.oGrid.Columns(m.i).AddProperty(m.cSavProperty, '')
						EndCase
						
						If not Empty(m.cNewDynamicBackColor)
							m.oGrid.Columns(m.i).DynamicBackColor = m.cNewDynamicBackColor
						EndIf
					EndFor
				EndIf
			Else
				*-- No se puede hacer un SetAll().
				*m.oGrid.SetAll('DynamicBackColor', '', 'Column')
				If (m.oGrid.ColumnCount > 0) ;
					and (Type('m.oGrid.Columns(1).' + m.cSavProperty) = 'C')
					
					For m.i = 1 To m.oGrid.ColumnCount
						m.oGrid.Columns(m.i).DynamicBackColor = Evaluate('m.oGrid.Columns(m.i).' + m.cSavProperty)
						RemoveProperty(m.oGrid.Columns(m.i), m.cSavProperty)
					EndFor
				EndIf
			EndIf
		
			m.oGrid.Refresh()
			m.oGrid.SetFocus()	&& Wrong refresh unless grid has focus. Use 'Help ActiveRow' for more info.
		EndIf
		
	ENDPROC

	PROCEDURE _setautosizecolumns		&& Set or reset auto size columns.
		Lparameters lSetAutoSizeColumns
		
		If not This.Enabled
			Return
		EndIf
		
		Local lResult As Logical, ;
				oGrid As Grid
		
		lResult = .f.
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O')
			If m.lSetAutoSizeColumns
				*-- Save and set propoerties.
				This.AddProperty('_OldAllowAutoColumnFit', m.oGrid.AllowAutoColumnFit)
				m.oGrid.AllowAutoColumnFit = 2 && Deactivate AutoColumnFit.
				This.AddProperty('_OldScrollBars', m.oGrid.ScrollBars)
				m.oGrid.ScrollBars = ICase(m.oGrid.ScrollBars = 3, 2, m.oGrid.ScrollBars = 1, 0, m.oGrid.ScrollBars) && Only vertical scroll bar.
		
				BindEvent(m.oGrid, 'MouseDown', This, '_OnGridMouseDown')
				BindEvent(m.oGrid, 'Resize', This, '_OnGridResize')
				lResult = .t.
			Else
				UnBindEvents(m.oGrid, 'Resize', This, '_OnGridResize')
				UnBindEvents(m.oGrid, 'MouseDown', This, '_OnGridMouseDown')
		
				*-- Restore old properties value.
				m.oGrid.ScrollBars = This._OldScrollBars
				RemoveProperty(This, '_OldScrollBars')
				m.oGrid.AllowAutoColumnFit = This._OldAllowAutoColumnFit
				RemoveProperty(This, '_OldAllowAutoColumnFit')
		
				lResult = .t.
			EndIf
		EndIf
		
		Return lResult
		
	ENDPROC

	HIDDEN PROCEDURE _setfind		&& Set or reset find box.
		Lparameters lSetFind
		
		If not This.Enabled
			Return
		EndIf
		
		Local lResult As Logical, ;
				oGrid As Grid, ;
				oColumn As Column, ;
				oObject As Object
		
		lResult = .f.
		
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O')
			If m.lSetFind
				*-- Activar el KeyPress.
				BindEvent(m.oGrid, 'KeyPress', This, '_OnGridKeypress')
				For Each m.oColumn In m.oGrid.Columns
					For Each m.oObject In m.oColumn.Objects
						If PemStatus(m.oObject, 'KeyPress', 5)
							BindEvent(m.oObject, 'KeyPress', This, '_OnGridKeypress')
						EndIf
					EndFor
				EndFor
				
				*-- Crear el objeto.
				ThisForm.AddObject('_oFindBox', 'FindBox', This)
				If (Type('Thisform._oFindBox') = 'O')
					lResult = .t.
				EndIf
				
			Else
				*-- Liberar el objeto.
				If (Type('Thisform._oFindBox') = 'O')
					ThisForm.RemoveObject('_oFindBox')
				EndIf
				
				*-- Desactivar el KeyPress.
				For Each m.oColumn In m.oGrid.Columns
					For Each m.oOject In m.oColumn.Objects
						If PemStatus(m.oColumn, 'KeyPress', 5)
							UnBindEvents(m.oObject, 'KeyPress', This, '_OnGridKeypress')
						EndIf
					EndFor
				EndFor
				UnBindEvents(m.oGrid, 'KeyPress', This, '_OnGridKeypress')
				
				lResult = .t.
			EndIf
		EndIf
		
		Return lResult
		
	ENDPROC

	HIDDEN PROCEDURE _setsort		&& Set or reset column header sort.
		Lparameters lSetSort
		
		If not This.Enabled
			Return
		EndIf
		
		Local oGrid As Grid, ;
			i As Integer, ;
			oDefaultColumn As Column, ;
			oColumn As Column, ;
			oHeader As Header, ;
			oAux As Object, ;
			cSortColumn As String
		
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O')
			m.oDefaultColumn = .f.
			If m.lSetSort and not Empty(This.SortColumns)
				m.cSortColumn = Upper(StrExtract(',' + Chrtran(This.SortColumns, ' ', '') + ',', ',', ','))
			Else
				m.cSortColumn = ''
			EndIf
			
			*-- Buscamos los header.
			For m.i = 1 To m.oGrid.ColumnCount
				If This._IsColumnSortable(m.oGrid, m.i)
					m.oColumn = m.oGrid.Columns(m.i)
					For Each m.oHeader As Header In m.oColumn.Controls
						If (Upper(m.oHeader.BaseClass) == 'HEADER')
							If m.lSetSort
								*-- Creamos el objeto BindEventHandler sobre el que hacer el BindEvent()
								*-- ya que no es posible saber el origen de un evento.
								This.AddObject('_oHeaderClickHandler_' + m.oColumn.Name, 'BindEventHandler', This, 'OnGridHeaderClick("' + m.oColumn.Name + '")')
								m.oAux = Evaluate('This._oHeaderClickHandler_' + m.oColumn.Name)
								If (Vartype(m.oAux) = 'O')
									BindEvent(m.oHeader, 'Click', m.oAux, 'Event')
								EndIf
								m.oColumn.AddProperty('_SortOrder', '')
								If (Vartype(m.oDefaultColumn) <> 'O') ;
									and ( ;
										Empty(m.cSortColumn) ;
										or ;
										(m.cSortColumn == Upper(m.oColumn.Name)) ;
									)
									
									m.oDefaultColumn = m.oColumn
								EndIf
							Else
								m.oAux = Evaluate('This._oHeaderClickHandler_' + m.oColumn.Name)
								If (Vartype(m.oAux) = 'O')
									UnBindEvent(m.oHeader, 'Click', m.oAux, 'Event')
									This.RemoveObject('_oHeaderClickHandler_' + m.oColumn.Name)
								EndIf
								RemoveProperty(m.oColumn, '_SortOrder')
							EndIf
						EndIf
					EndFor
				EndIf
			EndFor
			
			If (Vartype(m.oDefaultColumn) = 'O')
				This._OnGridHeaderClick(m.oDefaultColumn.Name)
			Else
				This._SetSortColumn(m.oDefaultColumn)
			EndIf
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE _setsortcolumn		&& Set column header passed as parameter as current sort column. If no header is passed then no header is setted.
		Lparameters oSelectedColumn As Column
		
		Local oGrid As Grid, ;
			oColumn As Column, ;
			oHeader As Header
		
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O')
			For Each m.oColumn In m.oGrid.Columns
				For Each m.oHeader In m.oColumn.Objects
					If (Upper(m.oHeader.BaseClass) == 'HEADER')
						If (Vartype(m.oSelectedColumn) = 'O') ;
							and (m.oColumn = m.oSelectedColumn) ;
							and (Type('m.oColumn._SortOrder') = 'C')
							
							m.oHeader.FontBold = .t.
							m.oHeader.Picture = ICase( ;
														(Upper(Alltrim(m.oColumn._SortOrder)) == 'ASC'), This.PictureSortAscending, ;
														(Upper(Alltrim(m.oColumn._SortOrder)) == 'DES'), This.PictureSortDescending, ;
														This.PictureSortAscending ;
													)
						Else
							m.oHeader.FontBold = .f.
							m.oHeader.Picture = ''
							If (Type('m.oColumn._SortOrder') = 'C')
								m.oColumn._SortOrder = ''
							EndIf
						EndIf
					EndIf
				EndFor
			EndFor
		EndIf
		
	ENDPROC

	HIDDEN PROCEDURE _unbindobject		&& Si el componente está vinculado lo desvincula.
		Local oGrid As Grid
		
		m.oGrid = This.oGrid
		If (Vartype(m.oGrid) = 'O')
			If This.AutoSizeColumnsEnabled
				This._SetAutoSizeColumns(.f.)
			EndIf
			If This.SortEnabled
				This._SetSort(.f.)
			EndIf
			If This.FindEnabled
				This._SetFind(.f.)
			EndIf
			If This.AlternateRowColorEnabled
				This._SetAlternateRowColor(.f.)
			EndIf
		EndIf
		
	ENDPROC

ENDDEFINE

DEFINE CLASS toolfindbox AS toolbar 
 	*< CLASSDATA: Baseclass="toolbar" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="txtFind" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Separator1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="btnNext" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="btnPrevious" UniqueID="" Timestamp="" />

	Caption = "Find"
	ColorSource = 4
	Height = 30
	KeyPreview = .T.
	Left = 0
	Name = "toolfindbox"
	Sizable = .F.
	Top = 0
	Width = 213

	ADD OBJECT 'btnNext' AS commandbutton WITH ;
		Caption = "", ;
		Height = 24, ;
		Left = 161, ;
		Name = "btnNext", ;
		Picture = pictures\findboxnext.bmp, ;
		PicturePosition = 14, ;
		Top = 3, ;
		Width = 24
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'btnPrevious' AS commandbutton WITH ;
		Caption = "", ;
		Height = 24, ;
		Left = 184, ;
		Name = "btnPrevious", ;
		Picture = pictures\findboxprevious.bmp, ;
		PicturePosition = 14, ;
		Top = 3, ;
		Width = 24
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'Separator1' AS separator WITH ;
		Height = 0, ;
		Left = 161, ;
		Name = "Separator1", ;
		Style = 1, ;
		Top = 3, ;
		Visible = .T., ;
		Width = 0
		*< END OBJECT: BaseClass="separator" />

	ADD OBJECT 'txtFind' AS textbox WITH ;
		Height = 23, ;
		Left = 5, ;
		Name = "txtFind", ;
		SpecialEffect = 1, ;
		Top = 3, ;
		Width = 149
		*< END OBJECT: BaseClass="textbox" />

ENDDEFINE
